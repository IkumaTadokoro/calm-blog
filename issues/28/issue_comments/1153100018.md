---
author_association: OWNER
created_at: '2022-06-12T08:19:47Z'
html_url: https://github.com/IkumaTadokoro/diary/issues/28#issuecomment-1153100018
id: 1153100018
issue_url: https://api.github.com/repos/IkumaTadokoro/diary/issues/28
node_id: IC_kwDOHWTPVs5Euujy
performed_via_github_app: 
reactions:
  "+1": 0
  "-1": 0
  confused: 0
  eyes: 0
  heart: 0
  hooray: 0
  laugh: 0
  rocket: 0
  total_count: 0
  url: https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1153100018/reactions
updated_at: '2022-06-12T08:19:47Z'
url: https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1153100018
user:
  avatar_url: https://avatars.githubusercontent.com/u/61409641?v=4
  events_url: https://api.github.com/users/IkumaTadokoro/events{/privacy}
  followers_url: https://api.github.com/users/IkumaTadokoro/followers
  following_url: https://api.github.com/users/IkumaTadokoro/following{/other_user}
  gists_url: https://api.github.com/users/IkumaTadokoro/gists{/gist_id}
  gravatar_id: ''
  html_url: https://github.com/IkumaTadokoro
  id: 61409641
  login: IkumaTadokoro
  node_id: MDQ6VXNlcjYxNDA5NjQx
  organizations_url: https://api.github.com/users/IkumaTadokoro/orgs
  received_events_url: https://api.github.com/users/IkumaTadokoro/received_events
  repos_url: https://api.github.com/users/IkumaTadokoro/repos
  site_admin: false
  starred_url: https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}
  subscriptions_url: https://api.github.com/users/IkumaTadokoro/subscriptions
  type: User
  url: https://api.github.com/users/IkumaTadokoro

---
# コンポーネントのイベント

> このページは、すでに[コンポーネントの基礎](http://localhost:3000/guide/essentials/component-basics.html)を読んでいることを前提にしています。初めてコンポーネントに触れる方は、まずそちらをお読みください。

## イベントの発行と購読

コンポーネントは組み込みの`$emit`メソッドを使用することで、テンプレート表現の中（例: `v-on`ハンドラの中）で直接カスタムイベントを発行することができます:

```vue
<!-- MyComponent -->
<button @click="$emit('someEvent')">click me</button>
```

親コンポーネントは`v-on`を使用することでそれを購読できます:

```vue
<MyComponent @some-event="callback" />
```

`once`修飾子はコンポーネントのイベントリスナーでもサポートされています。

```vue
MyComponent @some-event.once="callback" />
```


コンポーネントとプロパティと同じように、イベント名も自動的な大文字小文字の変換を提供しています。camelCaseのイベントを発行しても、親コンポーネントではケバブケースのリスナーを使用することでそれを購読できることに注意してください。プロパティと同様に、ケバブケースのイベントリスナをテンプレートで使用することを推奨します。

:::message
TIP
ネイティブのDOMイベントとは異なり、コンポーネントから発行されるイベントはバブリングされません。直接の子コンポーネントから発行されるイベントだけを購読することができます。
:::

## イベント引数

イベントと合わせて特定の値を発行することが便利な場合があります。例えば、`<BLogPost>`コンポーネントにテキストをどれだけ拡大させるかの責務を負わせたいとします。そのような場合、`$emit`に追加の引数を渡してこの値を提供することができます。

```vue
<button @click="$emit('increaseBy', 1)">
  Increase by 1
</button>
```

そして、親でイベントを購読する際に、インラインのアロー関数を利用することで、イベントの引数にアクセスすることができるようになります:

```vue
<MyButton @increase-by="(n) => count += n" />
```

もしくは、イベントハンドラはメソッドです:

```vue
<MyButton @increase-by="increaseCount" />
```

そして、その値はそのメソッドの最初のパラメータとして渡されます。

```vue
function increaseCount(n) {
  count.value += n
}
```

:::alert
TIP
イベント名の後ろの`$emit`に渡されたすべての追加引数はリスナーに転送されます。例えば、`emi('foo', 1, 2, 3)`とするとリスナー関数は3つの引数を受け取ります。
:::

## 発行されたイベントの宣言

発行されたイベントは`defineEmits()`マクロを使用してコンポーネント内で明示的に宣言することができます。

```vue
<script setup>
defineEmits(['inFocus', 'submit'])
</script>
```

`<template>`の中で使用されている`$emit`メソッドはコンポーネントの`<script setup>`セクションの中ではアクセスできませんが、`defineEmits()`は代わりに使用できる同等の関数を返します。

```vue
<script setup>
const emit = defineEmits(['inFocus', 'submit'])

function buttonClick() {
  emit('submit')
}
</script>
```

`defineEmits()`マクロは関数の中では使用できず、上記のサンプルのように、`<script setup>`の直下に配置する必要があります。

もし`<script setup>`の代わりに`setup`関数を明示的に使用しているならば、イベントは`emits`オプションを使用して宣言される必要があり、`emit`関数は`setup()`のコンテキスト上で公開されます。

```vue
export default {
  emits: ['inFocus', 'submit'],
  setup(props, ctx) {
    ctx.emit('submit')
  }
}
```

`setup`コンテキスト上の他のプロパティと同様に、`emit`は安全に分割代入することができます。

```vue
export default {
  emits: ['inFocus', 'submit'],
  setup(props, { emit }) {
    emit('submit')
  }
}
```

`emits`オプションはまたオブジェクト形式のシンタックスをサポートしており、発行されたイベントのペイロードの実行時バリデーションを行うことができます。

```vue
<script setup>
const emit = defineEmits({
  submit(payload) {
    // `true`または`false`を返します
    // バリデーション 合格 / 不合格
  }
})
</script>
```

もし`<script setup>`と共にTypeScriptを使用しているならば、純粋な型アノテーションを使用して発行されるイベントを宣言することもできます。

```vue
<script setup lang="ts">
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>
```

詳細: Typing Component Emits

任意ではありますが、コンポーネントがどのように動作すべきかをより良く文書化するために発行されるすべてのイベントを定義することが推奨されます。また、Vueは既知のリスナーをフォールスルー属性から除外することができます。

:::alert
TIP
もしネイティブイベント（例: `click`）が`emits`オプションで定義されると、リスナーはコンポーネントから発行される`click`イベントのみを購読するようになり、ネイティブの`click`イベントには対応しなくなります。
:::


## イベントのバリデーション

プロパティのタイプのバリデーションと同様に、発行されたイベントは配列のシンタックスの代わりにオブジェクトのシンタックスで定義されていれば検証されます。

バリデーションを追加するために、イベントには`emit`コールに渡された引数を受け取り、イベントが有効化どうかを示すboolean値を返す関数が割り当てられます。

```vue
<script setup>
const emit = defineEmits({
  // バリデーションなし
  click: null,

  // submitイベントを検証する
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  }
})

function submitForm(email, password) {
  emit('submit', { email, password })
}
</script>
```

## `v-model`での使用方法

カスタムイベントは`v-model`と連動するカスタム入力を作成するためにも使用できます。覚えておいてください:

```vue
<input v-model="searchText" />
```

は以下と同じものです:

```vue
<input
  :value="searchText"
  @input="searchText = $event.target.value"
/>
```

コンポーネントで使用する時、`v-model`は代わりにこれを行います:

```vue
<CustomInput
  :modelValue="searchText"
  @update:modelValue="newValue => searchText = newValue"
/>
```

しかしこれを実際に動作させるには、コンポーネント内の`<input>`が必要です:

- `value`属性を`modeValue`プロパティにバインドする
- `input`では、新しい値と共に`update:modelValue`イベントを発行する

その様子をご紹介します:

```vue
<!-- CustomInput.vue -->
<script setup>
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
</script>

<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>
```

これで`v-model`はこのコンポーネントで完全に動作するはずです:

```vue
<CustomInput v-model="searchText" />
```

`v-model`をコンポーネントの中で実装するもう一つの方法は書き込み可能な`computed`プロパティをgetterとsetterの両方とともに使用することです。`get`メソッドは`modelValue`プロパティを返す必要があり、`set`メソッドは対応するイベントを発行する必要があります。

```vue
<!-- CustomInput.vue -->
<script setup>
import { computed } from 'vue'

const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

const value = computed({
  get() {
    return props.modelValue
  },
  set(value) {
    emit('update:modelValue', value)
  }
})
</script>

<template>
  <input v-model="value" />
</template>
```

### `v-model`の引数

デフォルトでは、コンポーネント上の`v-model`は`modelValue`をプロパティとして、`update:modelValue`をイベントとして使用します。`v-model`に引数を渡すことでこれらの名称を変更することができます:

```vue
<MyComponent v-model:title="bookTitle" />
```

この場合、子コンポーネントは`title`プロパティを受け取り、親の値を更新するために`update:title`イベントを発行する必要があります。

```vue
<!-- MyComponent.vue -->
<script setup>
defineProps(['title'])
defineEmits(['update:title'])
</script>

<template>
  <input
    type="text"
    :value="title"
    @input="$emit('update:title', $event.target.value)"
  />
</template>
```

### 複数の`v-model`へのバインディング

以前`v-model`の引数で学んだように、特定のプロパティとイベントをターゲットにする機能を活用することで、1つのコンポーネントインスタンスに複数の`v-model`バインディングを作成できるようになりました。

```vue
<UserName
  v-model:first-name="first"
  v-model:last-name="last"
/>
```

```vue
<script setup>
defineProps({
  firstName: String,
  lastName: String
})

defineEmits(['update:firstName', 'update:lastName'])
</script>

<template>
  <input
    type="text"
    :value="firstName"
    @input="$emit('update:firstName', $event.target.value)"
  />
  <input
    type="text"
    :value="lastName"
    @input="$emit('update:lastName', $event.target.value)"
  />
</template>
```

### `v-model`修飾子のハンドリング

フォーム入力バインディングについて学習した時、`v-model`には組み込みの修飾子 - `.trim`、`.number`そして`.lazy`があることを見ました。しかしながら、カスタム修飾子を追加したい場合もあるでしょう。

サンプルのカスタム修飾子、`v-model`のバインディングとして提供された文字列の1文字目を大文字にする`capitalize`を作ってみましょう。

```vue
<MyComponent v-model.capitalize="myText" />
```

コンポーネントの`v-model`に追加された修飾子は`modelModifiers`プロパティを経由してコンポーネントに提供されます。以下の例では、デフォルト値が空のオブジェクトである`modelModifiers`プロパティを含むコンポーネントを作成しています。

```vue
<script setup>
const props = defineProps({
  modelValue: String,
  modelModifiers: { default: () => ({}) }
})

defineEmits(['update:modelValue'])

console.log(props.modelModifiers) // { capitalize: true }
</script>

<template>
  <input
    type="text"
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>
```

コンポーネントの`modelModifires`プロパティに`capitalize`が含まれており、その値が`true`であることに注意してください - これは`v-model`バインディング`v-model.capitalize="myText"`で設定されるためです。

これでプロパティの設定ができたので、modelModifiers オブジェクトのキーをチェックして、発行された値を変更するハンドラを書くことができます。以下のコードでは、`<input />`要素が`input`イベントを発生させるたびに、文字列を大文字にします。

```vue
<script setup>
const props = defineProps({
  modelValue: String,
  modelModifiers: { default: () => ({}) }
})

const emit = defineEmits(['update:modelValue'])

function emitValue(e) {
  let value = e.target.value
  if (props.modelModifiers.capitalize) {
    value = value.charAt(0).toUpperCase() + value.slice(1)
  }
  emit('update:modelValue', value)
}
</script>

<template>
  <input type="text" :value="modelValue" @input="emitValue" />
</template>
```

引数と修飾子の両方を持つ`v-model`バインディングの場合、生成されるプロパティ名は`arg` + `"Modifiers"`となります。例えば

```vue
<MyComponent v-model:title.capitalize="myText">
```

対応する宣言は:

```vue
const props = defineProps(['title', 'titleModifiers'])
defineEmits(['update:title'])

console.log(props.titleModifiers) // { capitalize: true }
```

---

## メモ

- `listening`: 購読 ? リッスン?
- `built-in`: ビルトイン ? 組み込み ?
- `template expressions`
- `handler`：ハンドラ ? ハンドラー
- `listener`: リスナ ? リスナー?
- `validation`: バリデーション / 検証

---

ライブラリの挙動とかを変える時に必要な知識（もちろんライブラリ側のコンポーネントが変更を許容していればの話だけれど）で、結構参考になった。