---
author_association: OWNER
created_at: '2022-08-07T05:17:51Z'
html_url: https://github.com/IkumaTadokoro/diary/issues/64#issuecomment-1207332997
id: 1207332997
issue_url: https://api.github.com/repos/IkumaTadokoro/diary/issues/64
node_id: IC_kwDOHWTPVs5H9nCF
performed_via_github_app: 
reactions:
  "+1": 0
  "-1": 0
  confused: 0
  eyes: 0
  heart: 0
  hooray: 0
  laugh: 0
  rocket: 0
  total_count: 0
  url: https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207332997/reactions
updated_at: '2022-08-07T05:17:51Z'
url: https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207332997
user:
  avatar_url: https://avatars.githubusercontent.com/u/61409641?v=4
  events_url: https://api.github.com/users/IkumaTadokoro/events{/privacy}
  followers_url: https://api.github.com/users/IkumaTadokoro/followers
  following_url: https://api.github.com/users/IkumaTadokoro/following{/other_user}
  gists_url: https://api.github.com/users/IkumaTadokoro/gists{/gist_id}
  gravatar_id: ''
  html_url: https://github.com/IkumaTadokoro
  id: 61409641
  login: IkumaTadokoro
  node_id: MDQ6VXNlcjYxNDA5NjQx
  organizations_url: https://api.github.com/users/IkumaTadokoro/orgs
  received_events_url: https://api.github.com/users/IkumaTadokoro/received_events
  repos_url: https://api.github.com/users/IkumaTadokoro/repos
  site_admin: false
  starred_url: https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}
  subscriptions_url: https://api.github.com/users/IkumaTadokoro/subscriptions
  type: User
  url: https://api.github.com/users/IkumaTadokoro

---
Hooksをさらっていく

## メリット

- クラスコンポーネントでしかできなかったstate管理が関数コンポーネントでもできるようになる
- クラスよりも記述量が少ない
- ロジックを分割できるので、ロジックの再利用やテストがしやすい

## useState

- stateは画面に表示されるデータやUIの状態など、APが保持している情報のこと
- Vueだとdata option
- 更新用の関数にはcallbackも渡せる（callback部分は疎になるので、外部に切り出すこともできる）
- オブジェクトを受け取ることもできるし、配列を受け取ることもできる。Object.isで比較判断しているので、際レンダリングがされるかは要チェック

## useEffect

- コンポーネントに副作用（DOMの変更とか、API通信、非同期処理などなど）を追加する。コンポーネントのレンダー後かアンマウント後に副作用を実行させることができる。

```
useEffect(副作用[, 依存配列])
```

- あ〜、Vue3でwatchEffectが追加されたのはこれがもとか〜。watchEffectもその中に含まれる値が変化した場合にだけ変更が走るけど、それに近い。
- 空配列を渡すと、1回だけ実行される
- 副作用内で関数を返すと、コンポーネントがアンマウント、もしくは副作用が再実行した時に実行される。これをクリーンアップ関数という。

## useRef

- refオブジェクト（React.createRefの戻り値）を返す
- DOMの参照やコンポーネントないで値を保持できる
- useStateと異なり、useRefで生成した値を更新してもコンポーネントは再レンダーされない（というわけでそういう文脈で使う）

いまいち腑に落ちないuseRef

- useStateでできることをわざわざuseRefでやる必要ない

## React.memo / useCallback / useMemo

- Reactでは不要な再計算やコンポーネントの再レンダリングを抑えることがパフォーマンス最適化の基本的な戦略

### React.memoとuseCallback

- コンポーネントのレンダー結果をメモ化するReactのAPI
- メモ化はアルゴリズムの文脈で使うものと同じ意味です
- レンダリングコストが低かったり、再レンダリングが頻繁に行われない場合は、使う意味あまりない

```
React.memo(FC)
```

- callbackをPropsとして受け取ったコンポーネントは、関数が再生成されることで再レンダリングが行われるため、React.memoは使えない。そのためuseCallbackを利用する。
- useCallbackを使って定義したcallbackを渡せば再レンダリングを避けることができる

### useMemo

- メモ化された値を返すフック

## useReducer

- stateとdispatchを返すフック
- stateがどのように更新されるのかは、useReducerに渡すreducer次第
- useStateとの使い分け
  - 複雑なstateの更新を行う際にuseReducerを利用する
  - stateの更新方法が複数ある場合にはuseReducerを使った方が便利

## Context / useContext（Context API or React Context）

- Contextは以下のいずれかを指す。
  1. Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactの仕組み
  2. Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactのAPI
  3. Contextオブジェクトのこと
　4. Contextオブジェクトの値のこと
- Contextを利用するためには次の3つが必要
　1. Contextオブジェクト
  2. Provider
  3. Consumer
- `React.createContext()`でContextオブジェクトを作成する。保持している値はProviderで共有できる
- ContextオブジェクトはProviderコンポーネントを保持している。Providerコンポーネントでラップすると、Providerのvalueの値を利用することができる。
- ConsumerはContextオブジェクトから値を取得しているコンポーネントのこと。useContextを利用する事で、Contextオブジェクトの値を参照することができる。

VueのProvide/Injectに近い

## カスタムフック

- 自前のフック
- VueのComposableと同じ。
- Vue Useみたいにユーティリティ集がある
