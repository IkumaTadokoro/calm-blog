<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>2022-08-07</title><meta name="next-head-count" content="3"/><link rel="preload" href="/diary/_next/static/css/d865616645a7b0fe.css" as="style"/><link rel="stylesheet" href="/diary/_next/static/css/d865616645a7b0fe.css" data-n-g=""/><link rel="preload" href="/diary/_next/static/css/fc9624fd4a486ef2.css" as="style"/><link rel="stylesheet" href="/diary/_next/static/css/fc9624fd4a486ef2.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/diary/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/diary/_next/static/chunks/webpack-dc4034d98607b727.js" defer=""></script><script src="/diary/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/diary/_next/static/chunks/main-a03413948affdc5e.js" defer=""></script><script src="/diary/_next/static/chunks/pages/_app-5b4d6b2692b4593b.js" defer=""></script><script src="/diary/_next/static/chunks/582-d79da0492f1f9267.js" defer=""></script><script src="/diary/_next/static/chunks/pages/articles/%5BissueNumber%5D-4584e21e841751ac.js" defer=""></script><script src="/diary/_next/static/PK-oHCoOK9fQiQKyKOFMS/_buildManifest.js" defer=""></script><script src="/diary/_next/static/PK-oHCoOK9fQiQKyKOFMS/_ssgManifest.js" defer=""></script><script src="/diary/_next/static/PK-oHCoOK9fQiQKyKOFMS/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><script>window.twttr=(function(f,b,g){var e,c=f.getElementsByTagName(b)[0],a=window.twttr||{};if(f.getElementById(g)){return a}e=f.createElement(b);e.id=g;e.src="https://platform.twitter.com/widgets.js";c.parentNode.insertBefore(e,c);a._e=[];a.ready=function(d){a._e.push(d)};return a}(document,"script","twitter-wjs"));</script><div class="min-h-screen flex flex-col"><header class="relative bg-gradient-to-r from-blue-700 via-blue-800 to-gray-900 md:mb-8"><div class="max-w-6xl mx-auto px-5"><nav class="py-12 md:mb-20 flex items-center justify-between md:px-12 px-2"><div><h1 class="text-white"><a class="text-2xl md:text-3xl tracking-wide font-bold" href="/diary">ikuma-t/diary</a></h1><p class="mt-4 text-sm text-slate-300">ikuma-tの作業ログです。</p></div><div><a class="text-white text-sm" href="https://github.com/IkumaTadokoro/diary/issues">Show on GitHub</a></div></nav></div><svg class="absolute w-full h-20 md:h-full top-32 left-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320" preserveAspectRatio="none"><path d="M0 32L24 37.3C48 43 96 53 144 74.7C192 96 240 128 288 122.7C336 117 384 75 432 80C480 85 528 139 576 133.3C624 128 672 64 720 53.3C768 43 816 85 864 90.7C912 96 960 64 1008 48C1056 32 1104 32 1152 58.7C1200 85 1248 139 1296 133.3C1344 128 1392 64 1416 32L1440 0V171H1416C1392 171 1344 171 1296 171C1248 171 1200 171 1152 171C1104 171 1056 171 1008 171C960 171 912 171 864 171C816 171 768 171 720 171C672 171 624 171 576 171C528 171 480 171 432 171C384 171 336 171 288 171C240 171 192 171 144 171C96 171 48 171 24 171H0V32Z" fill="white"></path></svg></header><main class="z-10 flex-1 py-8"><div class="max-w-2xl mx-auto"><article class="znc markdown"><section class="block py-6 md:px-12 px-8 bg-white md:rounded-lg border border-gray-200 shadow-md"><header><time class="text-xs text-gray-300 truncate" dateTime="2022-08-07T01:36:16Z" title="2022-08-07T01:36:16Z">2022-08-07 01:08:00</time><h1 class="font-bold text-slate-600">2022-08-07</h1></header><aside><p class="text-sm text-slate-400">Posted by <!-- --> at <!-- --><a href="https://github.com/IkumaTadokoro/diary/issues/64">#64</a>.<!-- --></p></aside><div></div></section><article class="mt-4"><section class="block py-6 px-8 md:px-12 bg-white md:rounded-lg border border-gray-200 shadow-md"><header><time class="text-xs text-gray-300 truncate" dateTime="2022-08-07T03:02:10Z" title="2022-08-07T03:02:10Z">2022-08-07 03:08:00</time></header><div><ul>
<li>React.StrictMode</li>
<li>React.FC (Functional Component）での型定義</li>
</ul>
</div></section></article><article class="mt-4"><section class="block py-6 px-8 md:px-12 bg-white md:rounded-lg border border-gray-200 shadow-md"><header><time class="text-xs text-gray-300 truncate" dateTime="2022-08-07T05:17:51Z" title="2022-08-07T05:17:51Z">2022-08-07 05:08:00</time></header><div><p>Hooksをさらっていく</p>
<h2 id="%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88"><a class="header-anchor-link" href="#%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88" aria-hidden="true" rel="nofollow"></a> メリット</h2>
<ul>
<li>クラスコンポーネントでしかできなかったstate管理が関数コンポーネントでもできるようになる</li>
<li>クラスよりも記述量が少ない</li>
<li>ロジックを分割できるので、ロジックの再利用やテストがしやすい</li>
</ul>
<h2 id="usestate"><a class="header-anchor-link" href="#usestate" aria-hidden="true" rel="nofollow"></a> useState</h2>
<ul>
<li>stateは画面に表示されるデータやUIの状態など、APが保持している情報のこと</li>
<li>Vueだとdata option</li>
<li>更新用の関数にはcallbackも渡せる（callback部分は疎になるので、外部に切り出すこともできる）</li>
<li>オブジェクトを受け取ることもできるし、配列を受け取ることもできる。Object.isで比較判断しているので、際レンダリングがされるかは要チェック</li>
</ul>
<h2 id="useeffect"><a class="header-anchor-link" href="#useeffect" aria-hidden="true" rel="nofollow"></a> useEffect</h2>
<ul>
<li>コンポーネントに副作用（DOMの変更とか、API通信、非同期処理などなど）を追加する。コンポーネントのレンダー後かアンマウント後に副作用を実行させることができる。</li>
</ul>
<div class="code-block-container"><pre class=""><code class="">useEffect(副作用[, 依存配列])
</code></pre></div><ul>
<li>あ〜、Vue3でwatchEffectが追加されたのはこれがもとか〜。watchEffectもその中に含まれる値が変化した場合にだけ変更が走るけど、それに近い。</li>
<li>空配列を渡すと、1回だけ実行される</li>
<li>副作用内で関数を返すと、コンポーネントがアンマウント、もしくは副作用が再実行した時に実行される。これをクリーンアップ関数という。</li>
</ul>
<h2 id="useref"><a class="header-anchor-link" href="#useref" aria-hidden="true" rel="nofollow"></a> useRef</h2>
<ul>
<li>refオブジェクト（React.createRefの戻り値）を返す</li>
<li>DOMの参照やコンポーネントないで値を保持できる</li>
<li>useStateと異なり、useRefで生成した値を更新してもコンポーネントは再レンダーされない（というわけでそういう文脈で使う）</li>
</ul>
<p>いまいち腑に落ちないuseRef</p>
<ul>
<li>useStateでできることをわざわざuseRefでやる必要ない</li>
</ul>
<h2 id="react.memo-%2F-usecallback-%2F-usememo"><a class="header-anchor-link" href="#react.memo-%2F-usecallback-%2F-usememo" aria-hidden="true" rel="nofollow"></a> React.memo / useCallback / useMemo</h2>
<ul>
<li>Reactでは不要な再計算やコンポーネントの再レンダリングを抑えることがパフォーマンス最適化の基本的な戦略</li>
</ul>
<h3 id="react.memo%E3%81%A8usecallback"><a class="header-anchor-link" href="#react.memo%E3%81%A8usecallback" aria-hidden="true" rel="nofollow"></a> React.memoとuseCallback</h3>
<ul>
<li>コンポーネントのレンダー結果をメモ化するReactのAPI</li>
<li>メモ化はアルゴリズムの文脈で使うものと同じ意味です</li>
<li>レンダリングコストが低かったり、再レンダリングが頻繁に行われない場合は、使う意味あまりない</li>
</ul>
<div class="code-block-container"><pre class=""><code class="">React.memo(FC)
</code></pre></div><ul>
<li>callbackをPropsとして受け取ったコンポーネントは、関数が再生成されることで再レンダリングが行われるため、React.memoは使えない。そのためuseCallbackを利用する。</li>
<li>useCallbackを使って定義したcallbackを渡せば再レンダリングを避けることができる</li>
</ul>
<h3 id="usememo"><a class="header-anchor-link" href="#usememo" aria-hidden="true" rel="nofollow"></a> useMemo</h3>
<ul>
<li>メモ化された値を返すフック</li>
</ul>
<h2 id="usereducer"><a class="header-anchor-link" href="#usereducer" aria-hidden="true" rel="nofollow"></a> useReducer</h2>
<ul>
<li>stateとdispatchを返すフック</li>
<li>stateがどのように更新されるのかは、useReducerに渡すreducer次第</li>
<li>useStateとの使い分け
<ul>
<li>複雑なstateの更新を行う際にuseReducerを利用する</li>
<li>stateの更新方法が複数ある場合にはuseReducerを使った方が便利</li>
</ul>
</li>
</ul>
<h2 id="context-%2F-usecontext%EF%BC%88context-api-or-react-context%EF%BC%89"><a class="header-anchor-link" href="#context-%2F-usecontext%EF%BC%88context-api-or-react-context%EF%BC%89" aria-hidden="true" rel="nofollow"></a> Context / useContext（Context API or React Context）</h2>
<ul>
<li>Contextは以下のいずれかを指す。
<ol>
<li>Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactの仕組み</li>
<li>Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactのAPI</li>
<li>Contextオブジェクトのこと<br>
　4. Contextオブジェクトの値のこと</li>
</ol>
</li>
<li>Contextを利用するためには次の3つが必要<br>
　1. Contextオブジェクト<br>
2. Provider<br>
3. Consumer</li>
<li><code>React.createContext()</code>でContextオブジェクトを作成する。保持している値はProviderで共有できる</li>
<li>ContextオブジェクトはProviderコンポーネントを保持している。Providerコンポーネントでラップすると、Providerのvalueの値を利用することができる。</li>
<li>ConsumerはContextオブジェクトから値を取得しているコンポーネントのこと。useContextを利用する事で、Contextオブジェクトの値を参照することができる。</li>
</ul>
<p>VueのProvide/Injectに近い</p>
<h2 id="%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%95%E3%83%83%E3%82%AF"><a class="header-anchor-link" href="#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%95%E3%83%83%E3%82%AF" aria-hidden="true" rel="nofollow"></a> カスタムフック</h2>
<ul>
<li>自前のフック</li>
<li>VueのComposableと同じ。</li>
<li>Vue Useみたいにユーティリティ集がある</li>
</ul>
</div></section></article></article></div></main><footer class="font-bold border-t-2 border-slate-100"><div class="max-w-6xl mx-auto px-5"><nav class="py-12"><ul class="flex justify-around text-white"><li><a href="/diary">Home</a></li><li><a href="https://ikuma-t.work">Blog</a></li></ul></nav></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"issue":{"body":"","bodyHTML":"","active_lock_reason":null,"assignee":null,"assignees":[],"author_association":"OWNER","closed_at":null,"comments":0,"comments_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/comments","created_at":"2022-08-07T01:36:16Z","events_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/events","html_url":"https://github.com/IkumaTadokoro/diary/issues/64","id":1330887437,"labels":[],"labels_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/labels{/name}","locked":false,"milestone":null,"node_id":"I_kwDOHWTPVs5PU7sN","number":64,"performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/reactions"},"repository_url":"https://api.github.com/repos/IkumaTadokoro/diary","state":"open","state_reason":null,"timeline_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/timeline","title":"2022-08-07","updated_at":"2022-08-07T01:36:16Z","url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64","user":{"avatar_url":"https://avatars.githubusercontent.com/u/61409641?v=4","events_url":"https://api.github.com/users/IkumaTadokoro/events{/privacy}","followers_url":"https://api.github.com/users/IkumaTadokoro/followers","following_url":"https://api.github.com/users/IkumaTadokoro/following{/other_user}","gists_url":"https://api.github.com/users/IkumaTadokoro/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/IkumaTadokoro","id":61409641,"login":"IkumaTadokoro","node_id":"MDQ6VXNlcjYxNDA5NjQx","organizations_url":"https://api.github.com/users/IkumaTadokoro/orgs","received_events_url":"https://api.github.com/users/IkumaTadokoro/received_events","repos_url":"https://api.github.com/users/IkumaTadokoro/repos","site_admin":false,"starred_url":"https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IkumaTadokoro/subscriptions","type":"User","url":"https://api.github.com/users/IkumaTadokoro"}},"issueComments":[{"body":"- React.StrictMode\n- React.FC (Functional Component）での型定義\n","bodyHTML":"\u003cul\u003e\n\u003cli\u003eReact.StrictMode\u003c/li\u003e\n\u003cli\u003eReact.FC (Functional Component）での型定義\u003c/li\u003e\n\u003c/ul\u003e\n","author_association":"OWNER","created_at":"2022-08-07T03:02:10Z","html_url":"https://github.com/IkumaTadokoro/diary/issues/64#issuecomment-1207320880","id":1207320880,"issue_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64","node_id":"IC_kwDOHWTPVs5H9kEw","performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207320880/reactions"},"updated_at":"2022-08-07T03:02:10Z","url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207320880","user":{"avatar_url":"https://avatars.githubusercontent.com/u/61409641?v=4","events_url":"https://api.github.com/users/IkumaTadokoro/events{/privacy}","followers_url":"https://api.github.com/users/IkumaTadokoro/followers","following_url":"https://api.github.com/users/IkumaTadokoro/following{/other_user}","gists_url":"https://api.github.com/users/IkumaTadokoro/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/IkumaTadokoro","id":61409641,"login":"IkumaTadokoro","node_id":"MDQ6VXNlcjYxNDA5NjQx","organizations_url":"https://api.github.com/users/IkumaTadokoro/orgs","received_events_url":"https://api.github.com/users/IkumaTadokoro/received_events","repos_url":"https://api.github.com/users/IkumaTadokoro/repos","site_admin":false,"starred_url":"https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IkumaTadokoro/subscriptions","type":"User","url":"https://api.github.com/users/IkumaTadokoro"}},{"body":"Hooksをさらっていく\n\n## メリット\n\n- クラスコンポーネントでしかできなかったstate管理が関数コンポーネントでもできるようになる\n- クラスよりも記述量が少ない\n- ロジックを分割できるので、ロジックの再利用やテストがしやすい\n\n## useState\n\n- stateは画面に表示されるデータやUIの状態など、APが保持している情報のこと\n- Vueだとdata option\n- 更新用の関数にはcallbackも渡せる（callback部分は疎になるので、外部に切り出すこともできる）\n- オブジェクトを受け取ることもできるし、配列を受け取ることもできる。Object.isで比較判断しているので、際レンダリングがされるかは要チェック\n\n## useEffect\n\n- コンポーネントに副作用（DOMの変更とか、API通信、非同期処理などなど）を追加する。コンポーネントのレンダー後かアンマウント後に副作用を実行させることができる。\n\n```\nuseEffect(副作用[, 依存配列])\n```\n\n- あ〜、Vue3でwatchEffectが追加されたのはこれがもとか〜。watchEffectもその中に含まれる値が変化した場合にだけ変更が走るけど、それに近い。\n- 空配列を渡すと、1回だけ実行される\n- 副作用内で関数を返すと、コンポーネントがアンマウント、もしくは副作用が再実行した時に実行される。これをクリーンアップ関数という。\n\n## useRef\n\n- refオブジェクト（React.createRefの戻り値）を返す\n- DOMの参照やコンポーネントないで値を保持できる\n- useStateと異なり、useRefで生成した値を更新してもコンポーネントは再レンダーされない（というわけでそういう文脈で使う）\n\nいまいち腑に落ちないuseRef\n\n- useStateでできることをわざわざuseRefでやる必要ない\n\n## React.memo / useCallback / useMemo\n\n- Reactでは不要な再計算やコンポーネントの再レンダリングを抑えることがパフォーマンス最適化の基本的な戦略\n\n### React.memoとuseCallback\n\n- コンポーネントのレンダー結果をメモ化するReactのAPI\n- メモ化はアルゴリズムの文脈で使うものと同じ意味です\n- レンダリングコストが低かったり、再レンダリングが頻繁に行われない場合は、使う意味あまりない\n\n```\nReact.memo(FC)\n```\n\n- callbackをPropsとして受け取ったコンポーネントは、関数が再生成されることで再レンダリングが行われるため、React.memoは使えない。そのためuseCallbackを利用する。\n- useCallbackを使って定義したcallbackを渡せば再レンダリングを避けることができる\n\n### useMemo\n\n- メモ化された値を返すフック\n\n## useReducer\n\n- stateとdispatchを返すフック\n- stateがどのように更新されるのかは、useReducerに渡すreducer次第\n- useStateとの使い分け\n  - 複雑なstateの更新を行う際にuseReducerを利用する\n  - stateの更新方法が複数ある場合にはuseReducerを使った方が便利\n\n## Context / useContext（Context API or React Context）\n\n- Contextは以下のいずれかを指す。\n  1. Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactの仕組み\n  2. Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactのAPI\n  3. Contextオブジェクトのこと\n　4. Contextオブジェクトの値のこと\n- Contextを利用するためには次の3つが必要\n　1. Contextオブジェクト\n  2. Provider\n  3. Consumer\n- `React.createContext()`でContextオブジェクトを作成する。保持している値はProviderで共有できる\n- ContextオブジェクトはProviderコンポーネントを保持している。Providerコンポーネントでラップすると、Providerのvalueの値を利用することができる。\n- ConsumerはContextオブジェクトから値を取得しているコンポーネントのこと。useContextを利用する事で、Contextオブジェクトの値を参照することができる。\n\nVueのProvide/Injectに近い\n\n## カスタムフック\n\n- 自前のフック\n- VueのComposableと同じ。\n- Vue Useみたいにユーティリティ集がある\n","bodyHTML":"\u003cp\u003eHooksをさらっていく\u003c/p\u003e\n\u003ch2 id=\"%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e メリット\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eクラスコンポーネントでしかできなかったstate管理が関数コンポーネントでもできるようになる\u003c/li\u003e\n\u003cli\u003eクラスよりも記述量が少ない\u003c/li\u003e\n\u003cli\u003eロジックを分割できるので、ロジックの再利用やテストがしやすい\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"usestate\"\u003e\u003ca class=\"header-anchor-link\" href=\"#usestate\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e useState\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003estateは画面に表示されるデータやUIの状態など、APが保持している情報のこと\u003c/li\u003e\n\u003cli\u003eVueだとdata option\u003c/li\u003e\n\u003cli\u003e更新用の関数にはcallbackも渡せる（callback部分は疎になるので、外部に切り出すこともできる）\u003c/li\u003e\n\u003cli\u003eオブジェクトを受け取ることもできるし、配列を受け取ることもできる。Object.isで比較判断しているので、際レンダリングがされるかは要チェック\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"useeffect\"\u003e\u003ca class=\"header-anchor-link\" href=\"#useeffect\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e useEffect\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eコンポーネントに副作用（DOMの変更とか、API通信、非同期処理などなど）を追加する。コンポーネントのレンダー後かアンマウント後に副作用を実行させることができる。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"code-block-container\"\u003e\u003cpre class=\"\"\u003e\u003ccode class=\"\"\u003euseEffect(副作用[, 依存配列])\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eあ〜、Vue3でwatchEffectが追加されたのはこれがもとか〜。watchEffectもその中に含まれる値が変化した場合にだけ変更が走るけど、それに近い。\u003c/li\u003e\n\u003cli\u003e空配列を渡すと、1回だけ実行される\u003c/li\u003e\n\u003cli\u003e副作用内で関数を返すと、コンポーネントがアンマウント、もしくは副作用が再実行した時に実行される。これをクリーンアップ関数という。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"useref\"\u003e\u003ca class=\"header-anchor-link\" href=\"#useref\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e useRef\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003erefオブジェクト（React.createRefの戻り値）を返す\u003c/li\u003e\n\u003cli\u003eDOMの参照やコンポーネントないで値を保持できる\u003c/li\u003e\n\u003cli\u003euseStateと異なり、useRefで生成した値を更新してもコンポーネントは再レンダーされない（というわけでそういう文脈で使う）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eいまいち腑に落ちないuseRef\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euseStateでできることをわざわざuseRefでやる必要ない\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"react.memo-%2F-usecallback-%2F-usememo\"\u003e\u003ca class=\"header-anchor-link\" href=\"#react.memo-%2F-usecallback-%2F-usememo\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e React.memo / useCallback / useMemo\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eReactでは不要な再計算やコンポーネントの再レンダリングを抑えることがパフォーマンス最適化の基本的な戦略\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"react.memo%E3%81%A8usecallback\"\u003e\u003ca class=\"header-anchor-link\" href=\"#react.memo%E3%81%A8usecallback\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e React.memoとuseCallback\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eコンポーネントのレンダー結果をメモ化するReactのAPI\u003c/li\u003e\n\u003cli\u003eメモ化はアルゴリズムの文脈で使うものと同じ意味です\u003c/li\u003e\n\u003cli\u003eレンダリングコストが低かったり、再レンダリングが頻繁に行われない場合は、使う意味あまりない\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"code-block-container\"\u003e\u003cpre class=\"\"\u003e\u003ccode class=\"\"\u003eReact.memo(FC)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ecallbackをPropsとして受け取ったコンポーネントは、関数が再生成されることで再レンダリングが行われるため、React.memoは使えない。そのためuseCallbackを利用する。\u003c/li\u003e\n\u003cli\u003euseCallbackを使って定義したcallbackを渡せば再レンダリングを避けることができる\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"usememo\"\u003e\u003ca class=\"header-anchor-link\" href=\"#usememo\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e useMemo\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eメモ化された値を返すフック\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"usereducer\"\u003e\u003ca class=\"header-anchor-link\" href=\"#usereducer\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e useReducer\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003estateとdispatchを返すフック\u003c/li\u003e\n\u003cli\u003estateがどのように更新されるのかは、useReducerに渡すreducer次第\u003c/li\u003e\n\u003cli\u003euseStateとの使い分け\n\u003cul\u003e\n\u003cli\u003e複雑なstateの更新を行う際にuseReducerを利用する\u003c/li\u003e\n\u003cli\u003estateの更新方法が複数ある場合にはuseReducerを使った方が便利\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"context-%2F-usecontext%EF%BC%88context-api-or-react-context%EF%BC%89\"\u003e\u003ca class=\"header-anchor-link\" href=\"#context-%2F-usecontext%EF%BC%88context-api-or-react-context%EF%BC%89\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e Context / useContext（Context API or React Context）\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eContextは以下のいずれかを指す。\n\u003col\u003e\n\u003cli\u003ePropsを利用せずにさまざまな階層のコンポーネントに値を共有するReactの仕組み\u003c/li\u003e\n\u003cli\u003ePropsを利用せずにさまざまな階層のコンポーネントに値を共有するReactのAPI\u003c/li\u003e\n\u003cli\u003eContextオブジェクトのこと\u003cbr\u003e\n　4. Contextオブジェクトの値のこと\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eContextを利用するためには次の3つが必要\u003cbr\u003e\n　1. Contextオブジェクト\u003cbr\u003e\n2. Provider\u003cbr\u003e\n3. Consumer\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReact.createContext()\u003c/code\u003eでContextオブジェクトを作成する。保持している値はProviderで共有できる\u003c/li\u003e\n\u003cli\u003eContextオブジェクトはProviderコンポーネントを保持している。Providerコンポーネントでラップすると、Providerのvalueの値を利用することができる。\u003c/li\u003e\n\u003cli\u003eConsumerはContextオブジェクトから値を取得しているコンポーネントのこと。useContextを利用する事で、Contextオブジェクトの値を参照することができる。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVueのProvide/Injectに近い\u003c/p\u003e\n\u003ch2 id=\"%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%95%E3%83%83%E3%82%AF\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%95%E3%83%83%E3%82%AF\" aria-hidden=\"true\" rel=\"nofollow\"\u003e\u003c/a\u003e カスタムフック\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e自前のフック\u003c/li\u003e\n\u003cli\u003eVueのComposableと同じ。\u003c/li\u003e\n\u003cli\u003eVue Useみたいにユーティリティ集がある\u003c/li\u003e\n\u003c/ul\u003e\n","author_association":"OWNER","created_at":"2022-08-07T05:17:51Z","html_url":"https://github.com/IkumaTadokoro/diary/issues/64#issuecomment-1207332997","id":1207332997,"issue_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64","node_id":"IC_kwDOHWTPVs5H9nCF","performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207332997/reactions"},"updated_at":"2022-08-07T05:17:51Z","url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207332997","user":{"avatar_url":"https://avatars.githubusercontent.com/u/61409641?v=4","events_url":"https://api.github.com/users/IkumaTadokoro/events{/privacy}","followers_url":"https://api.github.com/users/IkumaTadokoro/followers","following_url":"https://api.github.com/users/IkumaTadokoro/following{/other_user}","gists_url":"https://api.github.com/users/IkumaTadokoro/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/IkumaTadokoro","id":61409641,"login":"IkumaTadokoro","node_id":"MDQ6VXNlcjYxNDA5NjQx","organizations_url":"https://api.github.com/users/IkumaTadokoro/orgs","received_events_url":"https://api.github.com/users/IkumaTadokoro/received_events","repos_url":"https://api.github.com/users/IkumaTadokoro/repos","site_admin":false,"starred_url":"https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IkumaTadokoro/subscriptions","type":"User","url":"https://api.github.com/users/IkumaTadokoro"}}]},"__N_SSG":true},"page":"/articles/[issueNumber]","query":{"issueNumber":"64"},"buildId":"PK-oHCoOK9fQiQKyKOFMS","assetPrefix":"/diary","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>