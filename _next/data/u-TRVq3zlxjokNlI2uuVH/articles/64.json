{"pageProps":{"issue":{"body":"","bodyHTML":"","active_lock_reason":null,"assignee":null,"assignees":[],"author_association":"OWNER","closed_at":null,"comments":0,"comments_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/comments","created_at":"2022-08-07T01:36:16Z","events_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/events","html_url":"https://github.com/IkumaTadokoro/diary/issues/64","id":1330887437,"labels":[],"labels_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/labels{/name}","locked":false,"milestone":null,"node_id":"I_kwDOHWTPVs5PU7sN","number":64,"performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/reactions"},"repository_url":"https://api.github.com/repos/IkumaTadokoro/diary","state":"open","state_reason":null,"timeline_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64/timeline","title":"2022-08-07","updated_at":"2022-08-07T01:36:16Z","url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64","user":{"avatar_url":"https://avatars.githubusercontent.com/u/61409641?v=4","events_url":"https://api.github.com/users/IkumaTadokoro/events{/privacy}","followers_url":"https://api.github.com/users/IkumaTadokoro/followers","following_url":"https://api.github.com/users/IkumaTadokoro/following{/other_user}","gists_url":"https://api.github.com/users/IkumaTadokoro/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/IkumaTadokoro","id":61409641,"login":"IkumaTadokoro","node_id":"MDQ6VXNlcjYxNDA5NjQx","organizations_url":"https://api.github.com/users/IkumaTadokoro/orgs","received_events_url":"https://api.github.com/users/IkumaTadokoro/received_events","repos_url":"https://api.github.com/users/IkumaTadokoro/repos","site_admin":false,"starred_url":"https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IkumaTadokoro/subscriptions","type":"User","url":"https://api.github.com/users/IkumaTadokoro"}},"issueComments":[{"body":"- React.StrictMode\n- React.FC (Functional Component）での型定義\n","bodyHTML":"<ul>\n<li>React.StrictMode</li>\n<li>React.FC (Functional Component）での型定義</li>\n</ul>\n","author_association":"OWNER","created_at":"2022-08-07T03:02:10Z","html_url":"https://github.com/IkumaTadokoro/diary/issues/64#issuecomment-1207320880","id":1207320880,"issue_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64","node_id":"IC_kwDOHWTPVs5H9kEw","performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207320880/reactions"},"updated_at":"2022-08-07T03:02:10Z","url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207320880","user":{"avatar_url":"https://avatars.githubusercontent.com/u/61409641?v=4","events_url":"https://api.github.com/users/IkumaTadokoro/events{/privacy}","followers_url":"https://api.github.com/users/IkumaTadokoro/followers","following_url":"https://api.github.com/users/IkumaTadokoro/following{/other_user}","gists_url":"https://api.github.com/users/IkumaTadokoro/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/IkumaTadokoro","id":61409641,"login":"IkumaTadokoro","node_id":"MDQ6VXNlcjYxNDA5NjQx","organizations_url":"https://api.github.com/users/IkumaTadokoro/orgs","received_events_url":"https://api.github.com/users/IkumaTadokoro/received_events","repos_url":"https://api.github.com/users/IkumaTadokoro/repos","site_admin":false,"starred_url":"https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IkumaTadokoro/subscriptions","type":"User","url":"https://api.github.com/users/IkumaTadokoro"}},{"body":"Hooksをさらっていく\n\n## メリット\n\n- クラスコンポーネントでしかできなかったstate管理が関数コンポーネントでもできるようになる\n- クラスよりも記述量が少ない\n- ロジックを分割できるので、ロジックの再利用やテストがしやすい\n\n## useState\n\n- stateは画面に表示されるデータやUIの状態など、APが保持している情報のこと\n- Vueだとdata option\n- 更新用の関数にはcallbackも渡せる（callback部分は疎になるので、外部に切り出すこともできる）\n- オブジェクトを受け取ることもできるし、配列を受け取ることもできる。Object.isで比較判断しているので、際レンダリングがされるかは要チェック\n\n## useEffect\n\n- コンポーネントに副作用（DOMの変更とか、API通信、非同期処理などなど）を追加する。コンポーネントのレンダー後かアンマウント後に副作用を実行させることができる。\n\n```\nuseEffect(副作用[, 依存配列])\n```\n\n- あ〜、Vue3でwatchEffectが追加されたのはこれがもとか〜。watchEffectもその中に含まれる値が変化した場合にだけ変更が走るけど、それに近い。\n- 空配列を渡すと、1回だけ実行される\n- 副作用内で関数を返すと、コンポーネントがアンマウント、もしくは副作用が再実行した時に実行される。これをクリーンアップ関数という。\n\n## useRef\n\n- refオブジェクト（React.createRefの戻り値）を返す\n- DOMの参照やコンポーネントないで値を保持できる\n- useStateと異なり、useRefで生成した値を更新してもコンポーネントは再レンダーされない（というわけでそういう文脈で使う）\n\nいまいち腑に落ちないuseRef\n\n- useStateでできることをわざわざuseRefでやる必要ない\n\n## React.memo / useCallback / useMemo\n\n- Reactでは不要な再計算やコンポーネントの再レンダリングを抑えることがパフォーマンス最適化の基本的な戦略\n\n### React.memoとuseCallback\n\n- コンポーネントのレンダー結果をメモ化するReactのAPI\n- メモ化はアルゴリズムの文脈で使うものと同じ意味です\n- レンダリングコストが低かったり、再レンダリングが頻繁に行われない場合は、使う意味あまりない\n\n```\nReact.memo(FC)\n```\n\n- callbackをPropsとして受け取ったコンポーネントは、関数が再生成されることで再レンダリングが行われるため、React.memoは使えない。そのためuseCallbackを利用する。\n- useCallbackを使って定義したcallbackを渡せば再レンダリングを避けることができる\n\n### useMemo\n\n- メモ化された値を返すフック\n\n## useReducer\n\n- stateとdispatchを返すフック\n- stateがどのように更新されるのかは、useReducerに渡すreducer次第\n- useStateとの使い分け\n  - 複雑なstateの更新を行う際にuseReducerを利用する\n  - stateの更新方法が複数ある場合にはuseReducerを使った方が便利\n\n## Context / useContext（Context API or React Context）\n\n- Contextは以下のいずれかを指す。\n  1. Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactの仕組み\n  2. Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactのAPI\n  3. Contextオブジェクトのこと\n　4. Contextオブジェクトの値のこと\n- Contextを利用するためには次の3つが必要\n　1. Contextオブジェクト\n  2. Provider\n  3. Consumer\n- `React.createContext()`でContextオブジェクトを作成する。保持している値はProviderで共有できる\n- ContextオブジェクトはProviderコンポーネントを保持している。Providerコンポーネントでラップすると、Providerのvalueの値を利用することができる。\n- ConsumerはContextオブジェクトから値を取得しているコンポーネントのこと。useContextを利用する事で、Contextオブジェクトの値を参照することができる。\n\nVueのProvide/Injectに近い\n\n## カスタムフック\n\n- 自前のフック\n- VueのComposableと同じ。\n- Vue Useみたいにユーティリティ集がある\n","bodyHTML":"<p>Hooksをさらっていく</p>\n<h2 id=\"%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88\"><a class=\"header-anchor-link\" href=\"#%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88\" aria-hidden=\"true\" rel=\"nofollow\"></a> メリット</h2>\n<ul>\n<li>クラスコンポーネントでしかできなかったstate管理が関数コンポーネントでもできるようになる</li>\n<li>クラスよりも記述量が少ない</li>\n<li>ロジックを分割できるので、ロジックの再利用やテストがしやすい</li>\n</ul>\n<h2 id=\"usestate\"><a class=\"header-anchor-link\" href=\"#usestate\" aria-hidden=\"true\" rel=\"nofollow\"></a> useState</h2>\n<ul>\n<li>stateは画面に表示されるデータやUIの状態など、APが保持している情報のこと</li>\n<li>Vueだとdata option</li>\n<li>更新用の関数にはcallbackも渡せる（callback部分は疎になるので、外部に切り出すこともできる）</li>\n<li>オブジェクトを受け取ることもできるし、配列を受け取ることもできる。Object.isで比較判断しているので、際レンダリングがされるかは要チェック</li>\n</ul>\n<h2 id=\"useeffect\"><a class=\"header-anchor-link\" href=\"#useeffect\" aria-hidden=\"true\" rel=\"nofollow\"></a> useEffect</h2>\n<ul>\n<li>コンポーネントに副作用（DOMの変更とか、API通信、非同期処理などなど）を追加する。コンポーネントのレンダー後かアンマウント後に副作用を実行させることができる。</li>\n</ul>\n<div class=\"code-block-container\"><pre class=\"\"><code class=\"\">useEffect(副作用[, 依存配列])\n</code></pre></div><ul>\n<li>あ〜、Vue3でwatchEffectが追加されたのはこれがもとか〜。watchEffectもその中に含まれる値が変化した場合にだけ変更が走るけど、それに近い。</li>\n<li>空配列を渡すと、1回だけ実行される</li>\n<li>副作用内で関数を返すと、コンポーネントがアンマウント、もしくは副作用が再実行した時に実行される。これをクリーンアップ関数という。</li>\n</ul>\n<h2 id=\"useref\"><a class=\"header-anchor-link\" href=\"#useref\" aria-hidden=\"true\" rel=\"nofollow\"></a> useRef</h2>\n<ul>\n<li>refオブジェクト（React.createRefの戻り値）を返す</li>\n<li>DOMの参照やコンポーネントないで値を保持できる</li>\n<li>useStateと異なり、useRefで生成した値を更新してもコンポーネントは再レンダーされない（というわけでそういう文脈で使う）</li>\n</ul>\n<p>いまいち腑に落ちないuseRef</p>\n<ul>\n<li>useStateでできることをわざわざuseRefでやる必要ない</li>\n</ul>\n<h2 id=\"react.memo-%2F-usecallback-%2F-usememo\"><a class=\"header-anchor-link\" href=\"#react.memo-%2F-usecallback-%2F-usememo\" aria-hidden=\"true\" rel=\"nofollow\"></a> React.memo / useCallback / useMemo</h2>\n<ul>\n<li>Reactでは不要な再計算やコンポーネントの再レンダリングを抑えることがパフォーマンス最適化の基本的な戦略</li>\n</ul>\n<h3 id=\"react.memo%E3%81%A8usecallback\"><a class=\"header-anchor-link\" href=\"#react.memo%E3%81%A8usecallback\" aria-hidden=\"true\" rel=\"nofollow\"></a> React.memoとuseCallback</h3>\n<ul>\n<li>コンポーネントのレンダー結果をメモ化するReactのAPI</li>\n<li>メモ化はアルゴリズムの文脈で使うものと同じ意味です</li>\n<li>レンダリングコストが低かったり、再レンダリングが頻繁に行われない場合は、使う意味あまりない</li>\n</ul>\n<div class=\"code-block-container\"><pre class=\"\"><code class=\"\">React.memo(FC)\n</code></pre></div><ul>\n<li>callbackをPropsとして受け取ったコンポーネントは、関数が再生成されることで再レンダリングが行われるため、React.memoは使えない。そのためuseCallbackを利用する。</li>\n<li>useCallbackを使って定義したcallbackを渡せば再レンダリングを避けることができる</li>\n</ul>\n<h3 id=\"usememo\"><a class=\"header-anchor-link\" href=\"#usememo\" aria-hidden=\"true\" rel=\"nofollow\"></a> useMemo</h3>\n<ul>\n<li>メモ化された値を返すフック</li>\n</ul>\n<h2 id=\"usereducer\"><a class=\"header-anchor-link\" href=\"#usereducer\" aria-hidden=\"true\" rel=\"nofollow\"></a> useReducer</h2>\n<ul>\n<li>stateとdispatchを返すフック</li>\n<li>stateがどのように更新されるのかは、useReducerに渡すreducer次第</li>\n<li>useStateとの使い分け\n<ul>\n<li>複雑なstateの更新を行う際にuseReducerを利用する</li>\n<li>stateの更新方法が複数ある場合にはuseReducerを使った方が便利</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"context-%2F-usecontext%EF%BC%88context-api-or-react-context%EF%BC%89\"><a class=\"header-anchor-link\" href=\"#context-%2F-usecontext%EF%BC%88context-api-or-react-context%EF%BC%89\" aria-hidden=\"true\" rel=\"nofollow\"></a> Context / useContext（Context API or React Context）</h2>\n<ul>\n<li>Contextは以下のいずれかを指す。\n<ol>\n<li>Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactの仕組み</li>\n<li>Propsを利用せずにさまざまな階層のコンポーネントに値を共有するReactのAPI</li>\n<li>Contextオブジェクトのこと<br>\n　4. Contextオブジェクトの値のこと</li>\n</ol>\n</li>\n<li>Contextを利用するためには次の3つが必要<br>\n　1. Contextオブジェクト<br>\n2. Provider<br>\n3. Consumer</li>\n<li><code>React.createContext()</code>でContextオブジェクトを作成する。保持している値はProviderで共有できる</li>\n<li>ContextオブジェクトはProviderコンポーネントを保持している。Providerコンポーネントでラップすると、Providerのvalueの値を利用することができる。</li>\n<li>ConsumerはContextオブジェクトから値を取得しているコンポーネントのこと。useContextを利用する事で、Contextオブジェクトの値を参照することができる。</li>\n</ul>\n<p>VueのProvide/Injectに近い</p>\n<h2 id=\"%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%95%E3%83%83%E3%82%AF\"><a class=\"header-anchor-link\" href=\"#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%95%E3%83%83%E3%82%AF\" aria-hidden=\"true\" rel=\"nofollow\"></a> カスタムフック</h2>\n<ul>\n<li>自前のフック</li>\n<li>VueのComposableと同じ。</li>\n<li>Vue Useみたいにユーティリティ集がある</li>\n</ul>\n","author_association":"OWNER","created_at":"2022-08-07T05:17:51Z","html_url":"https://github.com/IkumaTadokoro/diary/issues/64#issuecomment-1207332997","id":1207332997,"issue_url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/64","node_id":"IC_kwDOHWTPVs5H9nCF","performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207332997/reactions"},"updated_at":"2022-08-07T05:17:51Z","url":"https://api.github.com/repos/IkumaTadokoro/diary/issues/comments/1207332997","user":{"avatar_url":"https://avatars.githubusercontent.com/u/61409641?v=4","events_url":"https://api.github.com/users/IkumaTadokoro/events{/privacy}","followers_url":"https://api.github.com/users/IkumaTadokoro/followers","following_url":"https://api.github.com/users/IkumaTadokoro/following{/other_user}","gists_url":"https://api.github.com/users/IkumaTadokoro/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/IkumaTadokoro","id":61409641,"login":"IkumaTadokoro","node_id":"MDQ6VXNlcjYxNDA5NjQx","organizations_url":"https://api.github.com/users/IkumaTadokoro/orgs","received_events_url":"https://api.github.com/users/IkumaTadokoro/received_events","repos_url":"https://api.github.com/users/IkumaTadokoro/repos","site_admin":false,"starred_url":"https://api.github.com/users/IkumaTadokoro/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/IkumaTadokoro/subscriptions","type":"User","url":"https://api.github.com/users/IkumaTadokoro"}}]},"__N_SSG":true}